원본은 velog에 작성해서 마크다운이 깨질 수 있습니다!! 원본 velog 링크 : https://velog.io/@dawnww/Next.js-Rendering
_* Mash-UP 15기 웹 팀 내 [Next.js 스터디](https://github.com/mash-up-kr/web-nextjs-study)에서 진행된 내용으로, 공식 문서와 공통된 자료를 읽고 정리하는 방식으로 진행되었습니다._
_** 정리하다 궁금한 내용(궁금한 내용이 아니더라도 스터디 시간에 얘기하고 싶은)은 ❓ 이모지로 정리해 두었습니다._

> **1주차 자료**
[Rendering](https://nextjs.org/docs/app/building-your-application/rendering)

---

# ✨ 렌더링
렌더링은 작성한 코드를 사용자 인터페이스로 변환하는 것을 의미.
React와 NextJS를 활용하면 코드의 일부가 서버나 클라이언트에서 렌더링될 수 있는 하이브리드 웹 애플리케이션을 제작할 수 있다.

</br>

## 💫 렌더링을 이해하기 위한 기초 개념 3가지

### 렌더링 환경 (서버/클라이언트)
![](https://velog.velcdn.com/images/jh0152park/post/8d4bf5ab-a168-4078-836d-54777ebcedaf/image.png)
#### 💻 클라이언트
애플리케이션 코드에 대한 요청을 서버에 보내는 사용자 장치의 브라우저. 받은 응답을 사용자 인터페이스로 전환한다. 

#### 💻 서버
애플리케이션 코드를 저장하고 클라이언트로부터 요청을 받은 후 적절한 응답을 보내는 데이터 센터의 컴퓨터.

</br>

### Request-Response Lifecycle
#### 1. User Action
사용자는 웹 애플리케이션과 상호작용한다.

#### 2. HTTP Request
클라이언트는 HTTP Request를 서버에 보낸다. 이때 요청된 리소스에 대한 필요한 정보와 사용되는 방법, 추가로 필요한 데이터를 포함하여 요청을 서버에 보낸다. 

#### 3. Server
서버는 요청을 처리하고 적절한 리소스로 응답한다. 이때 라우팅, 데이터 가져오기 등의 단계를 거칠 수 있다. 

#### 4. HTTP Response 
요청을 처리한 후, 서버는 클라이언트에 HTTP 응답을 다시 보낸다.

이때 응답에는 상태 코드(요청이 성공했는지 여부를 클라이언트에게 알려주기 위한 상태값) 와 요청했던 리소스들을 포함한다. 

#### 5. Client
클라이언트는 리소스를 파싱해서 유저 인터페이스를 렌더링한다. 

#### 6. User Action
사용자 인터페이스가 렌더링되면 사용자는 인터페이스와 상호작용 할 수 있으며, 전체 프로세스다 다시 시작된다. 
👉 여기서 전체 프로세스는 위에서 설명한 1~6단계를 의미한다. 


</br>

### Network Boundary
네트워크 바운더리(네트워크 경계)는 서로 다른 환경을 구분하는 개념적 선.
👉 예를 들어 클라이언트와 서버 / 서버와 데이터 저장소 가 있음

네트워크 바운더리는 두 가지로 나뉨.
서버에서 렌더링되는 모든 구성 요소 👉 서버 모듈 그래프
클라이언트에서 렌더링되는 모든 구성 요소 👉 클라이언트 모듈 그래프

모듈 그래프란, 애플리케이션의 파일이 어떻게 의존하는지 시각적으로 보여주는 것으로 생각하면 된다. 

네트워크 바운더리의 예시로는 `use client`와  `use server` 규칙을 통해 바운더리를 정의하는 것이 있다.

</br>

## 하이브리드 애플리케이션 구축
애플리케이션의 코드 흐름을 단방향으로 생각하는 것이 도움이 된다.
👉 응답 중에 애플리케이션 코드는 서버에서 클라이언트 방향으로 흐른다.

클라이언트에서 서버에 접근해야 하는 경우, 동일한 요청을 재사용하는 대신 서버에 새로운 요청을 보낸다.
👉 이렇게 하면 구성 요소를 렌더링 할 위치와 네트워크 바운더리를 배치할 위치를 이해하기 더 쉬워진다.

> ❓ 무슨 말일까.......... 동일한 요청을 재사용 하는 게 아니라 서버에 새로운 요청을 보내는 게 왜 더 좋은 방식인지 이해할 수 없다....
동일한 요청을 두 번 보내는 것보다 필요한 요청만 분리하여 한 번 더 보내는 게 더 좋다는 뜻?...

</br>

# ✨ Server Components
NextJS는 서버 컴포넌트를 사용한다. 이를 통해 추가적인 설정 없이 자동으로 서버 렌더링을 구현할 수 있으며, 필요할 때 선택적으로 클라이언트 컴포넌트를 사용할 수 있다. 


## 💫 서버 렌더링의 장점

### Data Fetching
서버 컴포넌트를 사용하면 데이터 소스에서 더 가까운 서버로 data fetching을 사용할 수 있다. 
👉 렌더링에서 필요한 데이터를 가져오는데 필요한 시간을 줄이고 클라이언트에서 만들어야 하는 요청 수를 줄여 성능을 향상시킬 수 있다.


### Security
Server Component는 토큰 및 API와 같은 민감한 데이터와 로직을 클라이언트에 노출할 위험 없이 서버에 유지할 수 있다.


### Caching
서버에서 렌더링하면 결과를 캐싱하여 후속 요청과 사용자 간에 재사용이 가능하다.

👉 성능을 향상시키고 각 요청에서 수행되는 렌더링 및 data fetching의 양을 줄임으로써 비용을 절감할 수 있다.


### Performance
server component는 기본 성능을 최적화할 수 있는 추가 도구가 제공된다.

👉 ex. 전체가 클라이언트 구성 요소로 구성된 앱의 경우, UI에서 상호작용이 필요하지 않은 컴포넌트를 서버 컴포넌트에서 동작시키면 JavaScript의 필요량을 줄일 수 있다.


### 초기 페이지 로드 및 Firsh Contentful Paint(FCP)
서버에서 사용자가 페이지를 죽시 볼 수 있도록 HTML을 생성할 수 있으며, 클라이언트 페이지를 렌더링하는데 필요한 JavaScript를 다운로드하고 실행하는 것을 기다릴 필요가 없다.


### SEO와 소셜 네트워크 공유 가능성 
렌더링된 HTML은 검색 엔진 봇이 페이지를 인덱싱하고 네트워크 봇이 페이지에 대한 소셜 카드 미리보기를 생성하는데 사용할 수 있다.


### Streaming
서버 컴포넌트를 사용하면 렌더링 작업을 청크로 나누고 준비되는 대로 클라이언트에 스트리밍 할 수 있다.
👉 사용자는 전체 페이지가 서버에서 렌더링될 때까지 기다리지 않고도 페이지의 일부를 더 일찍 볼 수 있다.

> ❓ 스트리밍을 자세히 알아보자~
밑에 내용 추가!

</br>

## 💫 서버 컴포넌트가 렌더링되는 방식
렌더링 작업은 개별 경로 세그먼트와 suspense boundaries로 나뉜다.

각 청크는 두 단계로 렌더링된다.

> 1. React는 서버 컴포넌트를 React Server Component Payload(RSC)라는 특별한 데이터 형식으로 렌더링한다.
</br>
2. NextJS는 RSC Payload와 클라이언트 컴포넌트 JavaScript instruction을 사용하여 서버에서 HTML을 렌더링한다.

이후, 클라이언트에서

> 1. HTML은 경로의 빠른 비대화형 미리보기를 즉시 표시하는데 사용된다. 
👉 이는 초기 페이지 로드에만 해당된다.
</br>
2. RSC Payload는 클라이언트와 서버 컴포넌트 트리를 조정하고 DOM을 업데이트하는 데 사용된다.
</br>
3. JavaScript instruction은 하이드레이트 클라이언트 컴포넌트를 사용하고 애플리케이션을 상호작용 가능하게 만든다.

> ❓ 하이드레이트란?
Server-Side에서 렌더링 된 정적 페이지(HTML)와 번들링 된 JS 파일을 클라이언트에게 보내면, Client-Side에서 HTML 코드와 JS(React) 코드를 서로 매칭시키는 과정
JS 코드들이 DOM 요소 위에 물을 채우듯 필요로 하던 요소들을 채운다 하여 붙여진 이름!
</br>
두 번씩이나 렌더링 되면 비효율적이지 않을까?
Server-Side에서 Pre-Rendering 된 문서는 모든 JS 요소들이 배제된 굉장히 가벼운 파일이므로 사용자에게 빠르게 로드되는 웹 페이지를 제공할 수 있다.
👉 이는 같은 화면에 두 번 렌더링이 발생한다는 단점을 충분히 보완할 수 있는 장점이다.

</br>

## 💫 서버 렌더링 전략

### Static Rendering(기본값)
정적 렌더링을 사용하면 route가 빌드 시간에 렌더링되거나 데이터 재검증 후에 백그라운드에서 렌더링된다. 
결과는 캐싱되어 Content Delivery Network(CDN)에 푸시될 수 있다. 

> ❓ Content Delivery Network란?

이 최적화를 통해 렌더링 작업의 결과를 사용자와 서버 요청 간에 공유할 수 있게 해 준다. 

정적 렌더링은 사용자가 개인화되지 않은 데이터가 있으며 빌드 시간에 알 수 있는 경우에 유용한다. 
ex. 정적 플로그, 제품 페이지 등


### Dynamic Rendering
동적 렌더링을 사용하면 각 사용자에 대해 **요청 시간**에 경로가 렌더링된다. 

동적 렌더링은 route에 사용자에게 개인화된 데이터가 있거나 쿠키나 URL의 검색 매개변수와 같이 요청 시에만 알 수 있는 정보가 있을 때 유용하다. 



### Streaming
![](https://nextjs.org/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Flight%2Fsequential-parallel-data-fetching.png&w=3840&q=75)
스트리밍은 서버에서 UI를 점진적으로 렌더링 할 수 있게 해 준다. 작업은 청크로 나뉘어지고 준비가 되는 대로 클라이언트로 스트리밍 된다.
👉 이를 통해 사용자는 전체 콘텐츠가 렌더링 되기 전에 페이지의 일부를 바로 볼 수 있다.


![](https://nextjs.org/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Flight%2Fserver-rendering-with-streaming.png&w=3840&q=75)
스트리밍은 NextJS 앱 라우터에 기본적으로 내장되어 있다.
👉 이는 초기 페이지 로딩 성능을 개선하는 데 도움이 되며, 전체 경로 렌더링을 차단할 수 있는 느린 data fetching에 의존하는 UI에도 도움이 된다.

</br>

# ✨ Cient Components
NextJS에서 클라이언트 컴포넌트를 사용하려면 파일 상단, import 위에 `"use client"` 지시어를 추가하여 사용할 수 있다.

`"use client"`는 서버와 클라이언트 컴포넌트 모듈 간의 경계를 선언하는데 사용된다. 파일에 `"use client"`를 정의함으로써, 자식 컴포넌트를 포함하여 그 안에 가져온 모든 모듈이 클라이언트 번들의 일부로 간주된다는 것을 의미한다.


## 💫 클라이언트 컴포넌트가 렌더링되는 방식
NextJS에서 클라이언트 컴포넌트는 요청이 전체 페이지 로드의 일부인지 / 후속 탐색인지에 따라 다르게 렌더링된다. 


### 전체 페이지 로드
초기 페이지 로드를 최적화하기 위해 NextJS는 React의 API를 사용하여 클라이언트 및 서버 컴포넌트 모두에 대해 서버에서 정적 HTML 미리보기를 렌더링한다.
👉 이는 사용자가 애플리케이션을 처음 방문할 때, 클라이언트가 클라이언트 컴포넌트 JavaScript 번들을 다운로드하고 파싱하며 실행하는 것을 기다리지 않고 페이지의 내용을 즉시 볼 수 있음을 의미한다.

#### 먼저 서버에서,
> 1. React는 서버 컴포넌트를 RSC Payload라는 특별한 데이터 형식으로 렌더링하며, 여기에는 클라이언트 컴포넌트에 대한 참조가 포함된다.
2. NextJS는 RSC Payload와 Client Component Javascript instruction을 사용하여 서버에서 경로에 대한 HTML을 렌더링한다.


#### 이후 클라이언트에서,
> 1. HTML은 경로의 빠르고 비상호작용적인 초기 미리보기를 즉시 표시하는데 사용된다.
2. RSC Payload는 클라이언트와 서버 컴포넌트 트리를 조정하고 DOM을 업데이트 하는 데 사용된다.
3. Javascript  instruction은 하이드레이트 클라이언트 구성 요소를 사용하고 UI를 상호작용 가능하게 만든다. 

👉 즉 , 클라이언트 컴포넌트는 RSC Payload가 실행되면서 인터렉티브 UI로 하이드레이트 되는 것임! 


### Subsequent Navigations
후속 탐색에서는 클라이언트 구성 요소가 서버에서 렌더링된 HTML 없이 완전히 클라이언트에서 렌더링 된다.

> ❓ 후속 탐색이라는 건 규리 언니가 저번에 말한 Hydration과 무슨 차이가 있는지 알아보기. 그럼 후속 탐색은 하이드레이트가 일어나지 않는 것으로 이해해도 되는 걸까?

</br>

# ✨ 서버와 클라이언트의 구성 패턴
React 애플리케이션을 구축할 때, 애플리케이션의 어떤 부분이 서버 또는 클라이언트에서 렌더링 되어야 하는지 고려해야 한다. 


## 💫  서버와 클라이언트 컴포넌트를 언제 사용해야 하는지 알아보자
![](https://velog.velcdn.com/images/dawnww/post/e4371fa9-10af-4a68-8aca-ea858858165f/image.png)
위 표를 통해, 데이터를 가져오고 백엔드 리소스에 직접 접근하고, 서버에 민감한 정보 등 서버나 데이터와 관련된 일을 할 때 서버 컴포넌트를 사용하며

이벤트 리스너나 상호작용, 상태 효과, 브라우저 API 관련된 기능이 필요할 때는 클라이언트 컴포넌트를 사용하는 것을 알 수 있다.

</br>

## 💫 서버 컴포넌트 패턴
클라이언트 측 렌더링을 선택하기 전에 데이터 가져오기, 데이터베이스 또는 백엔드 서비스에 접근하는 등을 서버 컴포넌트에서 수행할 수 있다.


### 컴포넌트 간 데이터 공유
서버에서 데이터를 가져올 때, 서로 다른 컴포넌트 간에 데이터를 공유해야 하는 경우가 있다.
ex) 동일한 데이터에 의존하는 레이아웃과 페이지

React Context 혹은 데이터를 props로 전달하는 대신, fetch 혹은 cache 함수를 사용하여 동일한 데이터를 필요로 하는 컴포넌트에서 데이터를 가져올 수 있으며, 동일한 데이터에 대해 중복 요청을 만드는 것에 대해 걱정할 필요가 없다.

👉 왜냐하면, fetch를 호가장하여 데이터 요청을 자동으로 메모이제이션하기 때문이다!!

> ❓ cache 함수는 fetch가 사용 불가능 할 때 사용할 수 있다고 되어있는데, 왜일까??


### 클라이언트 환경에서 서버 전용 코드 제외하기
JavaScript 모듈은 서버와 클라이언트 컴포넌트 모듈 사이에서 공유될 수 있으므로, 서버에서만 실행될 의도로 작성한 코드가 의도치 않게 클라이언트에서 실행될 수 있다.

👉 이를 방지하기 위함!


### Third-party 패키지 및 제공자 사용
서버 컴포넌트는 새로운 리액트 기능이기 때문에, 서드파티 패키지와 제공자들은 `"use client"` 지시어를 클라이언트 전용 기능을 사용하는 컴포넌트에 추가하기 시작하였다. 때문에 클라이언트 전용 기능을 사용하는 npm 패키지의 많은 구성 요소는 아직 지시어가 없다. 이러한 서드파티 클라이언트 컴포넌트는 클라이언트 컴포넌트 내에서는 예상대로 작동하지만, 서버 컴포넌트 내에서는 작동하지 않는다. 

ex) 캐러셀 패키지 내에 `useState`를 사용하지만 `"use client"` 지시어가 없는 경우 서버 컴포넌트에서 해당 패키지를 사용할 수 없다. 

👉 이러한 문제를 해결하기 위해 클라이언트 전용 기능에 의존하는 서드 파티 구성 요소를 클라이언트 컴포넌트로 감싸면 서버 컴포넌트에서 캐러셀을 사용할 수 있다. 

내가 든 의문이랑 비슷한 내용이었는데, 대부분의 서드파티 컴포넌트는 클라이언트 컴포넌트 내에서 사용할 가능성이 높기 때문에 컴포넌트를 래핑할 필요가 없다.

그러나, provider의 경우 react 상태와 context에 의존하여 애플리케이션의 루트에서 필요하므로 래핑하여 사용이 필요한 경우가 많다. 


## 💫 클라이언트 컴포넌트
### 클라이언트 컴포넌트를 트리 아래로 이동하기
클라이언트 JavaScript 번들 크기를 줄이기 위해 클라이언트 컴포넌트를 컴포넌트 트리 아래로 이동할 것을 권장한다 

> ❓ 클라이언트 컴포넌트 트리 자세히 알아보기!!

전체 레이아웃을 클라이언트 컴포넌트로 만드는 대신, 인터렉티브 로직을 클라이언트 컴포넌트로 이동하고 레이아웃은 서버 컴포넌트로 제작하면 레이아웃의 모든 컴포넌트 JavaScript를 클라이언트로 전송할 필요가 없다.

> 생각해보니까 이런 방법이 있었는데 나는 클라이언트 기능이 필요한 컴포넌트의 경우 전체를 클라이언트 컴포넌트로 선언하였다... 반성해야겠다...


### 서버에서 클라이언트 컴포넌트로의 props 전달
서버 컴포넌트에서 데이터를 가져오는 경우, 클라이언트 컴포넌트에 데이터를 props로 전달해야 할 수 있다.
👉 서버에서 클라이언트 컴포넌트로 전달된 props는 React에 의해 직렬화가 가능해야 한다.

>  ❓ 직렬화가 가능하다는 건 무엇일까?

클라이언트 컴포넌트가 직렬화할 수 없는 데이터에 의존하는 경우, 타 라이브러리를 이용하여 클라이언트에서 데이터를 가져오거나 Route Handler를 사용하여 서버에서 데이터를 가져올 수 있다. 


## 💫 서버와 클라이언트 컴포넌트의 교차 배치
> ❓ 여기 무슨 말인지 잘 모르겠다... ㅠㅠ

클라이언트 컴포넌트와 서버 컴포넌트를 교차할 때, UI를 컴포넌트의 트리로 시각화하는 것이 도움이 될 수 있다. 서버 컴포넌트인 루트 레이아웃에서 시작하여, "use client" 지시어를 추가함으로써 클라이언트에서 특정 서브트리의 컴포넌트를 렌더링할 수 있다. 

클라이언트 서브트리 내에서 서버 컴포넌트를 중첩하거나 서버 액션을 호출할 수 있지만, 주의해야 하는 사항이 몇 가지 있다.
> - request-response lifrcycle 동안, 코드는 서버에서 클라이언트로 이동한다.
👉 클라이언트에 있는 동안 서버의 데이터나 리소스에 접근해야 하는 경우, 서버에 새로운 요청을 하게 될 것이다. 
- 서버에 새로운 요청이 들어오면, 모든 서버 컴포넌트가 먼저 렌더링된다. 이때 클라이언트 컴포넌트 내부에 중첩된 컴포넌트도 포함된다. 
- 클라이언트 컴포넌트는 서버 컴포넌트 이후에 렌더링되므로 서버 컴포넌트를 클라이언트 모듈에 가져올 수 없다. 
👉 대신, 서버 컴포넌트를 클라이언트 컴포넌트에 props로 전달할 수 있다.

> 이전에 Next 했을 때 클라이언트 컴포넌트 안에 서버 컴포넌트를 가져와서 오류가 나는 경험을 했는데... 이걸 알았다면 바보같은 실수를 안 했을 것이다!! ㅠㅠ


즉, 서버 컴포넌트를 클라이언트 컴포넌트 안에 가져올 수 없으며 서버 컴포넌트를 클라이언트 컴포넌트에 props로 전달하는 것은 가능하다. 


# ✨ Runtime
NextJS는 두 가지 서버 런타임이 존재한다.

- Node.js 런타임
👉 애플리케이션을 렌더링할 때 사용된다. 

- 제한된 Edge API 런타임
👉 미들웨어(redirects, rewrites, setting header 등)


### 주의사항
 - 엣지 런타임은 Node.js API를 지원하지 않는다.
 👉 일부 패키지가 예상과 다르게 작동할 수 있으므로 주의해야 한다.
 - 엣지 런타임은 ISR을 지원하지 않는다.
 - 두 런타임 모두 배포 인프라에 스트리밍을 지원할 수 있다.
 
 > ❓ 왜 엣지 런타임은 ISR을 지원하지 않을까?


