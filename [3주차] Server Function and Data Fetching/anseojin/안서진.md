<h1> 📚 Next.js 3주차 학습정리

### 💡 Server Function and Data Fetching

- 리액트 서버 함수와 Next.js에서의 데이터 패칭에 대해 이해한다.

# 📍 Server Function

https://ko.react.dev/reference/rsc/server-functions

| 궁금증                                 | 내용                                                              |
| -------------------------------------- | ----------------------------------------------------------------- |
| **리액트 공식문서에 있는 "서버 함수"** | RSC(Server Components) 안에서 서버에서만 실행되는 함수 개념       |
| **`use server` 문법**                  | React 공식 문법 아님. Next.js 등 프레임워크에서 도입한 구현 방식  |
| **단독 리액트(CRA 등)에서 사용 가능?** | 안 됨. Next.js 같은 프레임워크 필요                               |
| **왜 리액트 공식 문서에 있음?**        | 리액트 자체가 제공하는 "개념"이기 때문 (프레임워크가 이걸 구현함) |

## 💡 서버 함수란?

- 서버 함수를 사용하면 클라이언트 컴포넌트가 서버에서 실행되는 비동기 함수를 호출할 수 있음.

1. 서버 함수를 `use server` 지시어로 정의
2. 프레임워크는 자동으로 서버 함수에 대한 **참조**를 생성, 해당 참조를 **클라이언트 컴포넌트**에 전달.
3. **[클라이언트]** 에서 해당 함수 호출되면,
4. React는 서버에 함수를 실행하라는 요청을 보내고 결과를 반환

(아래 내용 1번)

## 💡 서버 함수 사용법

### 1. 서버 컴포넌트에서 직접 서버 함수 정의하기

```
import Button from './Button';

function EmptyNote () {
  async function createNote() {
    // 서버 함수
    'use server';

    await db.notes.create();
  }

  return <Button onClick={createNote}/>;
}
```

⚡ 사용 방법

1. React가 EmptyNote 서버 컴포넌트를 렌더링
2. createNote 함수에 대한 참조를 생성
3. 그 참조를 Button **클라이언트 컴포넌트**에 전달
4. **버튼을 클릭**하면, React는 제공된 참조를 통해 createNote 함수를 실행하도록 **서버에 요청을 보냄.**

### 1-1. 클라이언트 컴포넌트에서 서버 함수 가져오기

- 클라이언트 컴포넌트는 "use server" 지시어를 사용하는 파일에서 서버 함수를 가져올 수 있음.

```
"use server";

export async function createNote() {
  await db.notes.create();
}
```

🔎 버튼 클릭으로 서버 함수 실행하고 싶다면 1번 혹은 1-1번 사용하면 됨.

### 1-2. 액션으로 서버 함수 구성하기

- 서버 함수는 클라이언트의 액션과 함께 구성할 수 있음
- 클라이언트의 액션으로 래핑하여 서버 함수의 isPending 상태에 접근

### 2. 서버 함수를 사용한 폼 액션

```
"use client";

import {updateName} from './actions';

function UpdateName() {
  return (
    <form action={updateName}>
      <input type="text" name="name" />
    </form>
  )
}
```

- 서버 함수를 폼에 전달하여 폼을 서버에 자동으로 제출할 수 있다.
- **폼 제출 성공**시, React는 자동으로 폼을 재설정.
- useActionState를 추가하여 대기(Pending) 상태 혹은 마지막 응답에 접근하거나, 점진적 향상을 지원가능

🔎 `<form>`으로 제출하고 싶은 경우 사용 - (폼 중심!)

### 3. useActionState를 사용한 서버 함수

- 액션 대기 상태 / 마지막으로 반환된 Response에 접근하는 경우에 `useActionState`를 사용하여 서버 함수를 호출 가능

```"use client";

import {updateName} from './actions';

function UpdateName() {
  const [state, submitAction, isPending] = useActionState(updateName, {error: null});

  return (
    <form action={submitAction}>
      <input type="text" name="name" disabled={isPending}/>
      {state.error && <span>Failed: {state.error}</span>}
    </form>
  );
}
```

- 서버함수와 함께 `useActionState` 사용하는 경우, React는 Hydration이 완료되기 전에 입력된 폼 제출을 자동으로 다시 실행함.

🔎 2번의 응용 버전 - 폼 제출 뿐 아니라 **상태까지** 관리하고 싶을 때

### 3-1. useActionState를 통한 점진적 향상

```
"use client";

import {updateName} from './actions';

function UpdateName() {
  const [, submitAction] = useActionState(updateName, null, `/name/update`);

  return (
    <form action={submitAction}>
      ...
    </form>
  );
}
```

- permalink가 useActionState에 제공될 때, 자바스크립트 번들이 로드되기 전에 폼이 제출되면 React는 제공된 URL로 리디렉션함.

🔎 3번과 3-1번을 함께 사용하면 폼 제출 시 상태 추적 + 사용자 경험 개선까지 할 수 있음.

# 📍 Data Fetching

https://nextjs.org/docs/app/building-your-application/data-fetching

- Next.js에서 데이터를 가져오고 (fetch), 효율적으로 캐싱하는 방법에 대해 알아본다.

## 1. Data Fetching and Caching

### 💡 Data Fetching Examples

### 1. 서버에서 `fetch API`로 데이터 가져오기

```
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

- 기본 서버 컴포넌트 방식
- fetch 함수의 응답은 디폴트로 캐시되지 X

- 경로 내에서 다른 동적 API를 사용하지 않는 경우, 페이지는 다음 빌드 시 정적 페이지로 사전 렌더링되고, 이후 데이터는 ISR을 통해 갱신 가능.

```
export const dynamic = 'force-dynamic'
```

위 코드를 사용하면, 페이지가 사전 렌더링되는 것을 막을 수 있음.

- 하지만, 실제로 cookies, headers, 또는 searchParams 같은 값을 읽는 경우가 많은데, 이러한 요소들을 사용하면 React가 자동으로 해당 페이지를 동적으로 렌더링하기 때문에 이런 경우에는 사용하지 않아도 된다.

> ❓ 사전 렌더링 왜막지?

### 2. ORM이나 Database로 서버에서 데이터 가져오기

- DB에서의 응답은 기본적으로 캐시되지 않지만, 추가 설정을 통해 캐시할 수 있음.
- 이하 내용은 "1. 서버에서 `fetch API`로 데이터 가져오기"랑 동일함

- ⚡ Next.js에서 데이터 패칭할 때는 fetch로 가져오든, ORM으로 DB에서 가져오든 렌더링 방식은 동일한 규칙을 따라간다

### 3. 클라이언트에서 데이터 가져오기

> 공식문서 왈 : 먼저 **server-side**에서 데이터를 가져오는 방식을 시도해보는 것을 권장한다.

하지만, 클라이언트 측에서 데이터를 가져와야 하는 불가피한 상황에는

- useEffect 안에서 fetch를 직접 호출 (권장X)
- SWR이나 React Query같은 라이브러리 사용

### 4. ORM이나 DB 쿼리 결과 캐싱하기

- `unstable_cache API`를 사용하면 Next.js 빌드 시점에 데이터베이스 응답을 캐싱할 수 있음.

```
import { unstable_cache } from 'next/cache'
import { db, posts } from '@/lib/db'

const getPosts = unstable_cache(
  async () => {
    return await db.select().from(posts)
  },
  ['posts'],
  { revalidate: 3600, tags: ['posts'] }
)

export default async function Page() {
  const allPosts = await getPosts()

  return (
    <ul>
      {allPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

- DB 쿼리 결과를 3600초 (1h) 동안 캐싱
- post 라는 캐시 태그를 통해 `ISR`을 통해 이 캐시를 선택적으로 무효화 가능

### 5. 동일한 데이터를 여러 함수에서 재사용하기

- 페이지에서 가져온 동일한 데이터를 여러 함수에서 재사용해야 할 때, `generateMetadata`와 `generateStaticParams` 같은 API를 사용함.

#### ⚡ fetch를 사용하는 경우

- `cache: 'force-cache'` 옵션을 추가하여 요청을 캐싱할 수 있음.
  - 동일한 URL에 동일한 옵션으로 요청을 보낼 경우, 단 한 번의 요청만 이루어지도록 보장한다는 의미

> Next.js 15 버전부터는 기본값이 cache: 'no-store'로 바뀜.

- 예전에는 fetch 요청 결과가 캐시에 저장돼서, 같은 요청을 여러 번 해도 서버에 다시 요청하지 않고 캐시된 데이터를 가져옴.
- 이제는 기본적으로 캐시를 사용하지 않고 매번 서버에 새로 요청해서 데이터를 가져오게 됨.

#### ⚡fetch 사용하지 않고 ORM이나 DB를 직접 사용하는 경우

- React의 cache 함수로 데이터 요청을 감싸면 된다.
  > 동일한 데이터 요청이 여러 번 있어도 cache()로 감싸면 내부적으로 React가 결과를 캐시에 저장하고 재사용해줘서 성능도 좋아지고 불필요한 쿼리도 방지할 수 있음.

## 💡 Patterns

![Patterns](image.png)

- 컴포넌트 안에서 데이터를 가져올 때에는 **두 가지 데이터 패칭 방식**을 알아야 함.

🔎 Parallel (병렬) & Sequential (순차적)

### 📍 Sequential Data Patching

- 컴포넌트 트리에서 요청들이 서로 의존적일 때 발생.
- 요청을 하나씩 순서대로 보내기 때문에 **전체 로딩 시간**이 길어질 수 있음.

- **중첩된 컴포넌트(nested components) 구조**에서 1) 각 컴포넌트가 자신의 데이터를 따로 요청, 2) 그 요청들이 메모이즈되지 않은 경우, 데이터 패칭은 순차적으로 이루어짐.

- 사용되는 경우 예시 : Playlists 컴포넌트가 **artistID**에 의존해서 데이터를 불러와야 한다면, Artist 컴포넌트의 데이터가 먼저 로드되어야 Playlists가 패칭을 시작할 수 있음.

  - 하나의 fetch가 다른 fetch의 결과에 의존하는 경우

- 📌 이런 상황에서도 전체 페이지가 멈춘 것처럼 보이지 않게 하기 위한 방법
  - loading.js (route segment 별 로딩 상태)
  - <Suspense> (중첩된 컴포넌트에서 로딩 분리)
  - 위의 방법을 활용하면 React가 데이터를 스트리밍으로 불러오면서 준비된 부분부터 먼저 화면에 보여줄 수 있음.

### 📍 Parallel Data Patching

- 서로 의존하지 않는 요청들이 동시에 수행됨.
- 전체 데이터 로딩 시간이 짧아짐

> 기본적으로 Next.js에서는 layout과 page 세그먼트가 병렬로 렌더링됨. 즉, 해당 세그먼트에서 발생하는 데이터 요청도 병렬로 시작된다는 것을 의미.

#### ⚡문제점

- Next.js에서 async/await를 사용할 때 동일한 컴포넌트 내에서 순차적으로 데이터를 요청하면 블로킹이 발생해 병렬이 아닌 순차적 요청처럼 처리될 수 있음.
  - 이유 :await가 호출 스택을 일시 중단시켜 아래쪽 요청들이 실행되지 못하기 때문

#### ⚡해결 전략

1. Promise.all을 활용해 독립적인 요청들을 동시에 시작함으로써 총 로딩 시간을 단축하기

```
const artistData = getArtist(username)
const albumsData = getAlbums(username)
const [artist, albums] = await Promise.all([artistData, albumsData])
```

- 두 요청을 동시에 시작하지만, 모든 결과가 준비될 때까지 렌더링이 지연된다는 한계가 존재

2. Suspense 경계 활용

```
<Suspense fallback={<ArtistSkeleton />}>
  <ArtistProfile />
</Suspense>
<Suspense fallback={<AlbumSkeleton />}>
  <AlbumList />
</Suspense>
```

- 데이터 도착 순서에 따라 UI를 점진적으로 표시 가능
  - 아티스트 정보와 앨범 목록을 각각 다른 Suspense 블록으로 감싸 독립적인 로딩 상태를 관리

### 📍 Preloading Data

> waterfall (데이터 요청이 순차적으로 발생해서 로딩이 느려지는 문제)를 피하는 방법 : preload

⚡ preload() : 데이터를 미리 요청해서 후속 렌더링이 더 빠르게 이루어지도록 도와주는 패턴. 순차적 요청을 피해서 성능을 개선함

🔎 `<Item />` 컴포넌트가 렌더링되려면 `checkIsAvailable()` 같은 함수가 먼저 실행되어야 한다고 가정

#### 해결

```
preload(); // 먼저 요청 시작

const isAvailable = await checkIsAvailable(); // 이후에 블로킹 요청
```

- preload() 같은 유틸리티 함수를 먼저 실행해서 `<Item />`이 렌더링되기도 전에 데이터 요청을 미리 시작
- 이 경우, `<Item />`이 렌더링될 땐 이미 데이터가 도착했을 가능성이 높음

📍 preload()

- preload()는 비동기적으로 요청만 시작
- 따라서, checkIsAvailable()을 막거나 지연 X
- 병렬적으로 돌아가기 때문에 전체 속도가 빨라짐

#### 💡 React에서 cahce + preload() + Server-only 세개를 같이 사용하면?!

- cache() → 데이터를 한 번만 요청해서 결과를 재사용 (memoize)

- Preload 패턴 → 컴포넌트가 렌더링되기 전에 데이터를 미리 요청해서 로딩 속도 향상

- server-only → 이 함수는 서버에서만 실행되게 보장
  (클라이언트로 노출되지 않도록 보호)

### 📍 민감한 데이터가 클라이언트로 노출되는 것 방지하기

- React의 taint API 사용하는 것을 추천

#### ⚡ taint API란?

- taintObjectReference
  → 객체 전체를 taint(오염)시켜서 클라이언트로 전달되지 않도록 막음

- taintUniqueValue
  → 특정 값 하나만 taint해서 클라이언트로 유출되지 않게 함

## 2. Server Actions and Mutations

## 3. Incremental Static Regeneration (ISR)
