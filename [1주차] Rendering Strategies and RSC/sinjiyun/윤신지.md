원본은 velog에 작성해서 마크다운이 깨질 수 있습니다!!
원본 velog 링크 : https://velog.io/@dawnww/Next.js-React-Server-Component


_* Mash-UP 15기 웹 팀 내 [Next.js 스터디](https://github.com/mash-up-kr/web-nextjs-study)에서 진행된 내용으로, 공식 문서와 공통된 자료를 읽고 정리하는 방식으로 진행되었습니다._
_** 정리하다 궁금한 내용(궁금한 내용이 아니더라도 스터디 시간에 얘기하고 싶은)은 ❓ 이모지로 정리해 두었습니다._

> **1주차 자료**
[웹 렌더링 전략 비교](https://nextjs.org/learn/seo/rendering-strategies)
[내 앱에 가장 적합한 렌더링 전략을 선택하는 방법](https://vercel.com/blog/how-to-choose-the-best-rendering-strategy-for-your-app)
[리액트 서버 컴포넌트](https://ko.react.dev/reference/rsc/server-components)

---

## 웹 렌더링 전략 비교
_자료 상 SSG,SSR, ISR, CSR 순서로 정리되어 있으나 편의를 위해 순서를 조금 변경하였습니다._

### Client Side Rendering (CSR)
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbfYO3T%2Fbtr53D5HiMO%2FdYI42mXnuktIDBPTBVWrQ0%2Fimg.png)

**최초에 single Page만 서버로부터 불러와 렌더링**하고 그 이후에는 모든 것을 클라이언트 사이드에서 렌더링하는 방식.
초기 페이지 로드 시 단일 HTML 파일이 제공되며, JavaScript를 가져오기 전까지 거의 혹은 전혀 콘텐츠가 존재하지 않음.

#### ✨ 특징
- 렌더링 하는 주체가 **클라이언트**(브라우저)
- HTML, CSS, JavaScript 등을 서버로부터 받아서 클라이언트 측에서 DOM 요소를 조작하여 내용을 출력
- **초반에 모두 다운로드 후 이후 새로운 페이지 요청에 데이터만 갱신**하여 해결

#### ✨ 장점
- **한 번 로딩되면 빠른 UX 제공**
부분적으로 필요한 내용만 불러와 업데이트를 하기 때문에 마치 앱을 사용하는 것과 같은 경험을 제공해 줌
- **서버의 부하가 적음**
부분적으로 데이터를 불러와서 UI를 업데이트하기 때문에, 상대적으로 서버의 부하가 적음
👉 View 렌더링을 브라우저가 담당하기 때문에 서버 트래픽을 감소시키고, 사용자에게 더 빠른 인터렉션을 제공해 줌


#### ✨ 단점
- **페이지 로딩 시간이 김**
첫 로드 시 서버로부터 필요한 자원을 응답받은 후, 렌더링을 하기 때문에 서버로부터 응답시간이 지연되면 초기 구동 속도가 느려짐
- **JavaScript 활성화 필수**
사용자가 JavaScript 사용 옵션을 비활성화한다면, React.js로 작성된 SPA는 정상적으로 동작하지 않음
- **SEO에 취약**
초기에 빈 HTML 파일만 받아서 사용하기 때문에 크롤러(검색봇)들이 어떤 내용이 있는지 확인하기 어려움
페이지마다 meta 태그 등에 정보를 따로 설정할 수 없음
최근 검색엔진은 SPA도 검색엔진에 색인이 되게끔 처리해주는 곳도 있긴 함

</br>


### Server-Side Rendering (SSR)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkLONB%2Fbtr5Rgqf5Hd%2F04Vrq80XgnfD9fHHSXKSd0%2Fimg.png)
런타임 동안 전체 HTML이 생성되는 방식. 동적 페이지가 있을 경우에 유리하다. 사이트 주소 요청 시 서버가 필요한 데이터를 받아 바로 사용자에게 보여주는 방식.
👉 서버는 페이지에 필요한 데이터를 즉시 얻어와 모두 삽입하고, CSS까지 모두 적용해 렌더링 준비를 마친 HTML과 JavaScript 코드를 브라우저에 응답으로 전달한다. 때문에 JavaScript 코드를 다운받고, 실행하기 전에 사용자가 이미 HTML이 렌더링 된 화면을 볼 수 있다.

#### ✨ 특징
- 렌더링 주체가 **서버**
  즉, HTML을 생성하여 응답해 줌
- **새로운 요청이 있을 때마다 렌더링**

#### ✨ 장점
- **페이지 로딩 시간이 빠름**
  클라이언트에서 요청한 페이지의 HTML을 다운로드 하기 때문에 초기 진입시 로딩이 빠름
- JavaScript를 필요로 하지 않음
- **SEO에 좋음**
  크롤러는 페이지를 인덱싱하기 위해 페이지에 관한 많은 정보가 필요한데, SSR을 활용하여 미리 페이지를 빌드하면 크롤러에게 많은 정보를 줄 수 있음
- 보안이 뛰어남
- 실시간 데이터를 보여줌
- 사용자별 필요한 데이터를 사용

#### ✨ 단점
- 요청마다 HTML을 생성하기 때문에 SSG 또는 ISR에 비해 **느림**
  CSR과 비교하여 빠르지만, 중복되는 내용도 다시 렌더링하여 받아야 하기 때문에 초기진입은 느린 편에 속함
- 너무 많은 요청으로 인해 **서버 과부화의 위험**이 있음
  SSR은 서버 측에서 처리해야 하는 렌더링 로직 때문에 반드시 응답을 처리해줄 서버가 필요. 트래픽이 많이 몰릴 경우 응답이 느려지거나, 메모리가 한도를 초과해 서버가 동작을 멈출 수 있음.
- **CDN 캐시가 이루어지지 않음**
  매 요청마다 콘텐츠를 읽어와 HTML에 포함하여 렌더링하기 때문에 cache를 하지 않음
- **페이지 이동할 때마다 화면이 깜박임**
 새로운 HTML을 받아오기 때문에 요청시마다 새로고침 되어 깜박임이 생김


</br>

### Static Site Generation(SSG)
빌드 시간에 HTML이 생성되는 방식. SSR이 요청 시간에 생성되는 것과 달리 빌드 시 HTML이 생성된다.
CSR과 SSR의 단점을 보완하기 위해서 매끄러운 서비스를 위해 서버에 화면을 저장해 두었다가 꺼내 쓰는 방식. 
👉 빌드 시 리액트 앱을 HTML로 미리 렌더링함.

#### ✨ 특징
- 서버에서 정적인 HTML을 미리 생성
- SSR과 비교하여, SSG는 미리 다 만들어둔 후 요청 시에 해당 페이지를 응답하기 때문에 필요한 페이지를 미리 준비해뒀다가 요청을 받으면 완성된 파일을 단순히 반환

#### ✨ 장점
- **페이지 로딩 시간이 빠름**
  - 이미 빌드할 때부터 페이지가 모두 렌더링되어 있으므로, 빠르게 페이지를 로딩할 수 있음
- JavaScript를 필요로 하지 않음
- 서버 부하가 감소함
- **SEO에 유리함**
- 보안이 뛰어남 
- CDN 캐시 가능

#### ✨ 단점
- **정적인 내용**
  - 이미 생성된 페이지를 제공하는 방식이기 때문에 사용자가 여러 요청을 하더라도 서버에 미리 준비된 페이지들을 가져가는 것 외에는 할 수 없음
- 실시간 데이터가 아님
- 사용자별 정보 제공의 어려움
- 페이지가 많은 사이트의 경우 빌드 시간이 증가함

</br>

### Incremental Static Regeneration (ISR)
전체 사이트를 다시 빌드할 필요 없이 **페이지별로 정적 생성을 사용**할 수 있게 해 줌.
빌드 시점에 페이지를 렌더링 한 후, 설정한 시간마다 페이지를 렌더링하는 방식.
👉 SSG에 포함되는 개념. SSG가 정적인 내용만 제공 가능하다는 단점을 보완한 렌더링 방식. SSG는 빌드 시에 페이지를 생성하기 때문에 fetching 하는 데이터가 변경되면 다시 빌드해야 하지만 ISR는 일정 시간마다 알아서 페이지를 업데이트 해 줌.

#### ✨ 특징
- **초기 페이지는 SSG처럼 정적으로 제공됨**
사용자가 요청하면 빌드된 정적 HTML을 반환해서 빠르게 응답 가능
- **설정한 주기마다 페이지를 다시 빌드**
데이터가 변경되었을 경우, 일정 시간이 지나면 새 데이터를 반영한 페이지를 생성함
즉, 최신 데이터가 반영된 페이지를 점진적으로 다시 생성할 수 있음
- **다음 사용자가 요청할 때 새 HTML을 반환**
새로운 데이터로 다시 생성한 HTML은 다음 요청에서 적용됨


#### ✨ 장점
- **빠른 페이지 로딩 속도**
초기에 빌드된 정적 HTML을 제공하므로 첫 로딩 속도가 매우 빠름
- **실시간 데이터 반영 가능**
SSG와 달리 일정 시간이 지나면 자동으로 페이지가 업데이트됨
- **전체 사이트를 다시 빌드할 필요 없음**
**특정 페이지만 다시 생성**할 수 있어서 빌드 시간이 길어지는 걸 방지할 수 있음
- **CDN 캐시 활용 가능**
정적 HTML을 제공하므로 CDN을 활용하여 성능 최적화가 가능

#### ✨ 단점
- **최신 데이터가 즉시 반영되지 않음**
SSR처럼 실시간으로 데이터를 불러오는 게 아니라, **정해진 주기가 지나야** 데이터가 갱신됨

- 첫 번째 요청에서만 느릴 수 있음
새로운 데이터를 반영하는 순간에는 백그라운드에서 새 HTML을 생성하는데,
첫 번째로 요청한 사용자는 이전 데이터를 보게 됨 (이후 요청부터는 새로운 페이지가 적용됨)


</br>

### CSR vs SSR vs SSG
![](https://velog.velcdn.com/images/dawnww/post/f565fcc3-9c5e-40f8-beaa-5acba1b69050/image.png)

---

## 내 앱에 가장 적합한 렌더링 전략을 선택하는 방법
_* 렌더링 방식 별 특징은 위에서 정리하였기 때문에 렌더링 전략을 선택하는 방식 위주로 정리하였습니다._

렌더링 전략을 선택할 때 고려해야 할 요소들을 정리하면,

### 콘텐츠가 얼마나 자주 변경되는지
SSG는 정적 콘텐츠에 적합하고, ISR은 주기적으로 변경되는 콘텐츠에 적합하며 SSR 혹은 CSR은 실시간 데이터에 적합하다. 
👉 가능한 한 SSG와 ISR에 의존하되, 신선한 데이터가 필요한 경우에만 SSR을 도입하는 것이 적절하다. 


### 검색 엔진에 얼마나 노출되어야 하는지
검색 엔진 상단에 노출시키기 위해서는 클라이언트 측에서 JavaScript를 로드하는 방식을 피하는 것이 좋다. 

> ❓ SSR, SSG, ISR끼리도 SEO에 영향을 줄까?...


### 사용자 상호작용이 얼마나 예상되는지
페이지가 대부분 정적이고 상호작용이 최소화된 경우, SSG 또는 ISR에 약간의 클라이언트 측 JS를 추가하는 방식이 좋음. 그러나 상호작용이 잦거나 정적 페이지가 아닌 경우 CSR 혹은 SSR을 사용하는 것이 유리함.


### 로드 시간이 얼마나 요구되는지
최초의 초기 로드를 위해 SSG 또는 ISR을 사용하는 것이 좋다. CSR는 실시간 데이터를 제공하지만, 초기 로드 시간이 오래 요구된다. 
만약 최신 데이터를 계속해서 불러와야 하며 초기 로드 시간 또한 줄여야 한다면 SSR 혹은 ISR을 사용하는 것이 유리하다.


### 개인화된 콘텐츠가 필요한지
SSG는 개인화를 허용하지 않기 때문에, 개인화된 콘텐츠가 필요하다면 SSR 혹은 CSR을 사용하는 것이 유리하다. 개인화된 콘텐츠를 캐시할 수 있는 경우 ISR도 가능하다. 


---
## 리액트 서버 컴포넌트
**서버 컴포넌트는 번들링 전에 클라이언트 앱이나 SSR 서버와는 분리된 환경에서 미리 렌더링 되는 새로운 유형의 컴포넌트이다.**

별도이 환경이 React 서버 컴포넌트에서의 **서버**이며, 서버 컴포넌트는 빌드 시간에 CI 서버에서 한 번 실행되거나, 각 요청마다 웹 서버를 통해 실행될 수 있다.

리액트 서버 컴포넌트는 오직 서버에서만 실행되는 컴포넌트를 생성할 수 있다.
👉 리액트 컴포넌트 내에서 바로 데이터베이스 쿼리를 작성하는 것과 같은 작업을 할 수 있다.

안타깝지만 RSC를 사용하는 유일한 방법은 Next 13 이상에서 새롭게 나온 App Router를 사용하는 방법 뿐이다.

> ❓ 왜 페이지 라우터에서는 RSC를 사용할 수 없을까?
App Router에서 서버에서 페이지의 정적인 부분을 즉시 클라이언트에게 HTML을 전달하여 브라우저에 렌더링하고, 동시에 **나머지 동적 데이터는 서버에서 호출된 응답 순서대로 클라이언트로 전달**하기 때문. (이 방식이 HTML Streamimg인데, 하단에 추가 설명)
</br>
Page Router의 경우 서버에서 **전체 페이지를 한 번에 렌더링**하고, 그 결과물을 클라이언트로 전달한다. 이때, 한 번 클라이언트로 전달된 이후로는 서버와의 연결이 끊어진다.


### 서버 컴포넌트는 왜 생겨났는가?
기존의 Page Router 방식에서는 서버와 클라이언트의 경계가 명확히 구분되어 있긴 하지만, 모든 것이 페이지 단위로 렌더링되다 보니 모든 데이터 페칭이 완료된 후에야 클라이언트로 HTML이 전달되는 구조였다. 이는 사용자에게 초기 콘텐츠를 보여주기까지의 시간이 길어지는 문제를 초래했다.

이를 해결하기 위해 **HTML Streaming**이 도입되었고, 이를 가능하게 하는 기술이 바로 서버 컴포넌트이다.

> ❓ 그렇다면 HTML Streamimg은 무엇일까?
**컴포넌트들을 각각 청크로 분리하고 나서 Suspense로 감싼 뒤에 리액트에게 컴포넌트를 기다리지 않고 우선 나머지 페이지에 대해서 HTML을 Streaming 할 수 있게 하는 기능**이다. 컴포넌트가 준비되기 전까지 fallback UI를 보여주도록 할 수도 있고, 각 컴포넌트들에게 우선순위도 정할 수 있다.
</br>
👉 화면의 일부가 최초 HTML을 보내는 작업을 지연시키면, 해당 부분만 HTML 스트리밍 상에 나중에 들어오게 할 수 있으며, 작업이 완료된다면 Stream으로 script와 함께 컴포넌트를 넣어주기 때문에 데이터가 순서에 맞춰 로딩될 필요가 없다.


### 서버 컴포넌트의 예시
```javascript
import db from 'imaginary-db';

async function Homepage() {
  const link = db.connect('localhost', 'root', 'password');
  const data = await db.query(link, 'SELECT * FROM products');

  return (
    <>
      <h1>Trending Products</h1>
      {data.map((item) => (
        <article key={item.id}>
          <h2>{item.title}</h2>
          <p>{item.description}</p>
        </article>
      ))}
    </>
  );
}

export default Homepage;
```

만약 위 코드가 클라이언트 컴포넌트였다면, `async function`을 컴포넌트에 직접 사용하고, 렌더 함수 내에서 사이드 이펙트를 사용하여 렌더링 때마다 요청이 발생하여 성능 이슈와 불필요한 요청이 발생하는 등의 문제가 생겼을 것이다. 

그러나 서버 컴포넌트는 **다시 렌더링하지 않아도 되기** 때문에 문제가 생기지 않는다. 서버에서 한 번 렌더링 된 값은 클라이언트로 전송되어 제자리에 고정되기 때문에 다른 페이지로 이동하는 등의 변경이 없다는 전제 하에 절대 변경되지 않을 것이다. 

위와 같은 내용으로 단순히 장단점을 생각해보면, 
상황에 따라 변경되어야 하는 상태(state), 클라이언트에서 렌더링 된 후에 실행되는 이펙트는 사용할 수 없다는 단점이 있다.
반대로 기존에는 사이드 이펙트가 매 렌더링마다 반복되지 않도록 useEFfect 콜백이나 이벤트 핸들러 안에 넣어야 했지만, 컴포넌트가 한 번만 실행되기 때문에 이러한 걱정을 하지 않아도 된다는 장점이 있다.


> **리액트 서버 컴포넌트 vs 서버 사이드 렌더링**
중요하게 짚고 넘어가야 할 부분은, **리액트 서버 컴포넌트는 SSR을 대체하지 않는다**는 사실이다.
초기 HTML을 생성하기 위해서는 여전히 SSR에 의존해야 한다. 그러나 리액트 서버 컴포넌트는 **특정 컴포넌트가 클라이언트 쪽 자바스크립트 번들에 포함되지 않게, 즉 서버에서만 실행되게 할 수 있다.**
SSR 없이 리액트 서버 컴포넌트를 사용하는 것이 가능하긴 하지만, 함께 사용한다면 더 좋은 결과를 얻을 수 있다.


> 조쉬 코모가 추천하는 서버 컴포넌트를 사용해야 하는 때
어떤 기준으로 서버/클라이언트 컴포넌트를 구분해야 할지 고민이 될 때
일반적으로는 서버 컴포넌트를 만들 수 있다면 만드는 것이 좋다. 서버 컴포넌트는 더 간단하고 이해하기 쉬우며 클라이언트에서 실행되지 않기 때문에 JavaSciprt 번들에 코드가 포함되지 않아 성능상 이점이 있다.
</br>
하지만 그렇다고 해서 단순히 클라이언트 컴포넌트를 없애거나 최소한으로 줄이는 것을 목표로 잡아선 안 된다. 이전까지 모든 리액트 앱의 모든 컴포넌트는 클라이언트 컴포넌트였다는 것을 잊어서는 안 된다.
</br>
직관적으로 보았을 때, 상태 변수나 이펙트를 사용하는 컴포넌트는 반드시 클라이언트 컴포넌트여야 한다. 그렇다면 나머지 컴포넌트들을 서버 컴포넌트로 남겨두면 되는 것이다. 

### client boundaries
만약 상위 컴포넌트만 클라이언트 컴포넌트고, 하위 컴포넌트들이 서버 컴포넌트라면 하위 컴포넌트들도 함께 렌더링되어야 할 것이다. 하지만 하위 컴포넌트들이 서버 컴포넌트이기 때문에 다시 렌더링할 방법이 없다.

이러한 상황을 위해 리액트에서 추가된 규칙은 **클라이언트 컴포넌트가 import 하는 컴포넌트는 반드시 클라이언트 컴포넌트가 되어야 한다.** 는 규칙이다. 

즉, 상위 컴포넌트에 `'use client'` 지시문을 사용하면 하위 인스턴스들도 클라이언트 컴포넌트로 변환된다. 이러한 방식은 client boundaries를 생성하기 위함이다. 
때문에 상위 컴포넌트가 클라이언트 컴포넌트일 경우에는 지시문 없이도 암시적으로 클라이언트 컴포넌트로 변환되기 때문에, 클라이언트에서 렌더링 된다.

---
### 참고 자료
[Making Sense of React Server Components](https://www.joshwcomeau.com/react/server-components/)
[React 서버 컴포넌트 작동원리를 아주 쉽게 알아보자](https://blog.kmong.com/react-server-component%EB%A1%9C-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C-%ED%98%81%EC%8B%A0%ED%95%98%EA%B8%B0-part-2-5cf0bf4416b0)
[React Streaming SSR 알아보기](https://velog.io/@tlsakch510/React-Streaming-SSR-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0)




