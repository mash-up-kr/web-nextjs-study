<h1> 📚 Next.js 4주차 학습정리

## 💡 How to create layouts and pages
- Next.js는 **파일 시스템 기반** 라우팅을 이용함. (폴더와 파일을 이용해서 라우트를 정의할 수 있다는 뜻)
    - Next.js에선 파일 이름과 위치만 잘 정하면 자동으로 URL 경로(route)를 만들어줌.

### 📍  Creating a page 
- **page** : 특정 경로(route)에 렌더링되는 UI. 
- Next.js에서는 app 폴더 안에 page.tsx 또는 page.js 파일을 만들고, 거기에 React 컴포넌트를 기본 export 하면 그게 곧 해당 경로의 페이지가 됨.

```
export default function Page() {
  return <h1>Hello Next.js!</h1>
}
```
- app 디렉토리 안에 page 파일을 만들고, 그 안에서 React 컴포넌트를 기본(default)으로 export


### 📍  Creating a layout
- **layout** : 여러 페이지에서 공유되는 UI (ex. 공통으로 사용되는 헤더, 네비게이션 바 등)
- 페이지를 이동해도 레이아웃은 상태를 유지하고, 인터랙티브한 상태도 그대로이며, 다시 렌더링되지 않음.

```
// app/layout.tsx
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body>
        <header>공통 헤더</header>
        <main>{children}</main>   // <-- 여기에 인덱스 페이지가 들어감!
        <footer>공통 푸터</footer>
      </body>
    </html>
  );
}
```

```
// app/page.tsx (인덱스 페이지)
export default function HomePage() {
  return <div>여기가 인덱스 페이지야!</div>;
}
```

이렇게 해두면 브라우저에서 /에 접속했을 때 Next.js가 알아서

```
<RootLayout>
  <HomePage />
</RootLayout>
```

이런 구조로 자동으로 감싸서 보여준다. 

- layout.tsx는 외부 틀 (공통 구조)
- page.tsx는 내부 내용 (화면마다 달라지는 부분)

### 정리 
- app/layout.tsx는 모든 페이지의 기본 틀이 되는 루트 레이아웃
- 루트 레이아웃은 무조건 있어야 하고, 그 안에는 <html>과 <body> 태그를 직접 작성해야 함. -> Next.js가 이걸 바탕으로 전체 페이지 구조를 만들어줌.

### 📍 Creating a nested root

- **nested route(중첩 라우트)** : 여러개의 URL segment로 구성된 라우트 
  - ```/blog/[slug]```는 세개의 조각으로 나뉨. 
    - ```/``` : 루트 세그먼트
    - ```blog``` : 중간 세그먼트
    - ```[slug]``` : 마지막 세그먼트 <- 보통 동적 라우팅에 사용 

- Next.js에서는 
  - folders : URL 경로를 정의하는데 사용 (폴더 이름이 URL 경로의 한 부분이 된다)
  - files : 그 경로에서 보여질 UI를 만드는데 사용 

- 중첩 라우트를 이용하고 싶다면 폴더를 서로 중첩해서 사용하면 됨. 
  -  /blog 경로를 만들고 싶다면, app 디렉토리 안에 blog라는 폴더를 만들면 됨
  - /blog 경로를 실제로 열 수 있게 하려면, 그 blog 폴더 안에 page.tsx 파일을 추가!

```
/app
 └── blog
      └── page.tsx   ← 여기 파일이 실제로 /blog 페이지로 보이게 됨!
```

- 폴더 이름을 대괄호([ ])로 감싸면 **동적 라우트 세그먼트(dynamic route segment)** 가 만들어짐. 
  - 데이터를 기반으로 여러 개의 페이지를 만들 때 사용. (블로그 글, 제품 상세 페이지 등)

### 📍  Nesting Layouts
- 기본적으로 폴더 구조에 따라 layout도 중첩됨
- 중첩 레이아웃 구성 
  - 특정 경로(폴더)에 layout.tsx 파일을 추가하면, 그 경로에만 적용되는 레이아웃을 만들 수 있움.

![nestinglayouts](nestinglayouts.png)
-  두 개의 레이아웃(루트 레이아웃과 블로그 레이아웃)을 같이 사용한다면, ```app/layout.js```에 있는 루트 레이아웃이 ```app/blog/layout.js``` 에 있는 블로그 전용 레이아웃을 감싼다.
- 블로그 레이아웃은 ```/blog``` 페이지와 ```/blog/[slug]``` 페이지를 감싼다.

```
export default function BlogLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return <section>{children}</section>
}
```
1. ```BlogLayout``` 이라는 레이아웃 컴포넌트 만든다 
  → 블로그 관련 페이지들에만 적용되는 틀이 되는 레이아웃

2. ```children``` : 이 레이아웃 안에 들어갈 실제 페이지 내용
  - ```/blog/page.tsx``` 나 ```/blog/[slug]/page.tsx``` 등

3. 브라우저에는 이렇게 렌더링됨
```
<section>
  <!-- blog/page.tsx 내용 -->
</section>
```


### 📍 Linking between Pages 
- Next.js에서는 <Link> 컴포넌트를 사용해서 페이지 간 이동을 할 수 있다.
  -  ```<Link> ``` : 기본 HTML ```<a>``` 태그를 확장한 Next.js 전용 컴포넌트
  - prefetching (미리 로딩하는 것)과 클라이언트 사이드 navigation 제공 

```
import Link from 'next/link';

<Link href="/blog">블로그로 이동</Link>

```
- next/link에서 <Link>를 불러오고, href 속성을 넣어줌.

- ```<Link>```는 Next.js 앱에서 경로 간 이동을 할 때 가장 기본적이고 권장되는 방법이지만, 좀 더 복잡한/동적인 이동이 필요할 때는  ```useRouter``` 훅을 사용할 수 있음. 


## 💡 Linking and Navigating
- 링크 연결과 페이지 이동 

#### Next.js 에서 페이지간 이동하는 방법 
1. ```<Link>``` 컴포넌트 사용 (→ 가장 기본적이고 추천)
2. ```useRouter``` 훅 사용 (클라이언트 컴포넌트에서만 사용 가능)
3. ```redirect()``` 함수 사용 (서버 컴포넌트에서 사용됨)
4. 브라우저의 기본 ```History API```를 직접 사용

---
### 📍 1. ```<Link>``` 컴포넌트 사용하기
- 위에서 설명함

### 📍 2. ```useRouter``` 훅 사용하기
-  useRouter 훅을 사용하면, 클라이언트 컴포넌트에서 프로그래밍적으로 경로를 변경할 수 있다.
  - ```<Link>``` : 클릭하면 자동으로 이동하는 (정적인) 방법
  - ```useRouter``` : 코드로 직접 이동시키는 (동적인) 방법

👀 경로를 이동할 때는 ```<Link>``` 컴포넌트를 사용하는 것을 적극 권장. (useRouter은 정말 필요할때만 써라!) -  *```<Link>```  가 Next.js가 최적화해서 처리해주는 기본 방식이라 가장 안정적이고 성능도 좋음* 

### 📍 3. ```redirect()``` 함수 사용하기
- ```redirect()``` 는 서버 컴포넌트 또는 서버 액션에서만 쓸 수 있는 함수로, 특정 경로로 강제 이동(리디렉션) 시킬 수 있음. 

- 브라우저에서 리다이렉트 되는 게 아니라, 서버에서 아예 다른 페이지로 응답을 돌려주기 때문에 사용자가 ```"/profile"``` 에 들어오더라도 자동으로 ```"/login"``` 이나 ```"/join"``` 으로 이동하게 만든다

#### import 하는 방법 
```
import { redirect } from 'next/navigation'
```

```
export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
```
- params: URL에서 받은 값
  -  ```/profile/123``` 이라면 ```params.id === '123'```

```
  const { id } = await params
  if (!id) {
    redirect('/login')
  }
```
- id가 없다면 (즉, URL이 이상하거나 유저 정보가 없으면), **즉시 ```/login``` 페이지로 강제 이동시킴**

```
  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }
```
- ```fetchTeam()``` 함수가 실패하거나 결과가 없다면, ```/join``` 으로 즉시 이동!

👀 ```redirect('/경로')``` 는 서버에서 조건 맞으면 (렌더링 없이) 즉시 이동시기 때문에 서버 컴포넌트에서 로그인 체크, 권한 검사, 데이터 존재 여부 등 처리할 때 사용하면 좋음. 

👍🏻  Good to Know
1. redirect는 기본적으로 307 (임시 리디렉션) 상태 코드를 반환한다. 서버 액션에서 사용될 경우에는 303 (다른 위치 보기) 상태 코드를 반환하며, 이는 주로 POST 요청 후 성공 페이지로 리디렉션할 때 사용된다.
2. redirect는 내부적으로 에러를 발생시키므로, try/catch 블록 밖에서 호출해야 한다.
3. redirect는 렌더링 중인 클라이언트 컴포넌트에서는 호출할 수 있지만, 이벤트 핸들러 안에서는 사용할 수 없다. 이런 경우에는 useRouter 훅을 대신 사용할 수 있다.
4. redirect는 **절대 경로(URL)**도 받을 수 있으며, 이를 통해 외부 링크로도 리디렉션이 가능하다.
5. 렌더링 전에 리디렉션을 하고 싶다면, next.config.js 또는 Middleware를 사용해야 한다.


### 📍 4. 브라우저의 기본 ```History API```를 직접 사용하기
- Next.js는 기본 브라우저 API인 ```window.history.pushState``` 와 ```window.history.replaceState``` 메서드를 사용할 수 있게 해주며, 이 메서드들을 통해 페이지를 새로 고침하지 않고도 브라우저의 히스토리 스택을 업데이트할 수 있음.

- 이 ```pushState```와 ```replaceState``` 호출은 Next.js의 라우터 시스템과도 통합되어 있어서 ```usePathname```이나 ```useSearchParams``` 같은 훅과 함께 연동해서 사용할 수도 있음. 

### ```window.history.pushState ```
- 브라우저의 히스토리 스택에 새로운 항목을 추가할 때 사용
- 사용자는 뒤로 가기 버튼을 눌러 이전 상태로 돌아감.


### ```window.history.replaceState```
- 브라우저의 히스토리 스택에서 현재 항목을 교체할 때 사용
- 사용자는 이전 상태로 되돌아갈 수 없음



## 📍 How Routing and Navigation Works
- App Router는 라우팅과 내비게이션을 처리할 때 **하이브리드 방식(서버 + 클라이언트 혼합)** 을 사용함. 

- **서버** 에서는 애플리케이션 코드가 라우트 세그먼트 단위로 자동으로 코드 분할됨.
  - 경로별로 필요한 코드만 나눠서 로딩한다는 의미 
- **클라이언트** 에서는  Next.js가 라우트 세그먼트를 미리 불러오고(prefetch) 캐싱까지 해둠. 
  - 바뀐 라우트 세그먼트만 다시 렌더링되기 때문에, 내비게이션 경험과 성능이 향상

⚡️ Next.js 의 App Router는 1. 서버에서 코드 분할, 2. 클라이언트에서 미리 로드와 캐싱, 3. 그리고 필요한 부분만 렌더링하는 구조로 빠르고 부드럽게 페이지 전환 가능하게 해줌.

- **Route Segment** : URL 경로의 각 부분을 의미하는 단위

---
### 1. 코드 분할 
- 애플리케이션 코드를 작은 번들로 나눠서 브라우저가 필요한 것만 다운로드하고 실행할 수 있게 해주는 기술. 
- 각 요청마다 전송되는 데이터량이 줄고 실행 시간도 줄어들어서 성능을 향상시킬 수 있음.

📌  Next.js의 **서버 컴포넌트(Server Components)** 는 이걸 자동으로 처리해줌.
 - 라우트 세그먼트 단위로 코드를 자동 분할해주기 때문에, 사용자가 어떤 페이지로 이동할 때 그 경로에 필요한 코드만 로딩됨.

### 2. Prefetching (사전에 불러오기)
- 사용자가 아직 방문하지 않았더라도, 백그라운드에서 해당 경로에 대한 데이터를 미리 불러오는 기능

#### Next.js에서 prefetching이 일어나는 방식 
- ```<Link>``` 컴포넌트 사용 시: Link가 뷰포트(화면)에 보이면 자동으로 해당 경로를 미리 로드해줌.
  - 페이지 처음 로딩 시, 또는 스크롤해서 화면에 들어올 때 prefetch가 발생!
- ```router.prefetch()``` 사용 시: useRouter 훅을 이용하면, 프로그래밍적으로 prefetch를 제어 가능 (ex. 버튼 클릭 시 특정 경로를 미리 로드)


- ```Link``` 의 prefetch 동작은 상황에 따라 조금 달라진다. 
  - prefetch 속성을 명시하지 않거나 null로 둔 경우 : 
    - loading.js가 처음 나오는 시점까지의 layout만 prefetch되고, 나머지는 안 함.
    - 즉, 공통 레이아웃까지만 미리 캐싱되고, 전체 동적 페이지 전체를 미리 다 가져오는 것은 아님. 
    - 비용이 줄어들고, 대신 사용자에겐 로딩 상태를 보여줄 수 있다는 장점이 있음

- ```prefetch``` 옵션 제어
  - ```prefetch={false}``` → 미리 불러오지 않음
  - ```prefetch={true}``` → 로딩 경계를 넘어 전체 페이지 데이터까지 prefetch함

👀 Prefetching은 개발 환경에서는 X. 배포 환경에서만 O

### 3. Caching
- Next.js에는 **Router Cache(라우터 캐시)** 라고 불리는 클라이언트 메모리 기반의 캐시가 있음.
- 사용자가 앱 내에서 페이지를 이동할 때, 미리 불러온(route prefetch된) 라우트 세그먼트나 이미 방문한 페이지의 React Server Component Payload가 이 캐시에 저장됨. 

- 사용자가 다른 페이지로 이동할 때 서버에 새로 요청을 보내는 대신 **이미 캐시에 있는 데이터를 최대한 재사용** 한다는 뜻
  - 불필요한 요청과 데이터 전송이 줄어들기 때문에 성능이 향상됨. 

### 4. Partial Rendering
- 페이지를 이동할 때 **변경된 라우트 세그먼트만** 클라이언트에서 다시 렌더링되고, 공유된 세그먼트는 그대로 유지되는 것을 의미. (= 변하는 세그먼트만 새로 렌더링되고, 공통된 부모 레이아웃은 그대로 유지!)

- ```/dashboard/settings``` → ```/dashboard/analytics``` 로 이동할 경우:
  - settings 페이지 : unmount(제거)됨
  - analytics 페이지 : 새 상태로 mount(생성)됨
  - 둘이 공유하고 있는 dashboard 레이아웃 : 유지됨.

- 동적 세그먼트 내의 페이지 전환에서도 동일하게 작동한다. ```/blog/[slug]/page ``` 구조에서 ```/blog/first``` → ```/blog/second```로 이동할 때: 
  - 공통된 ```/blog``` 레이아웃은 유지됨
  - ```[slug]```에 해당하는 콘텐츠만 바뀜! 

![partial rendering](partialrendering.png)

- partial rendering이 없으면 페이지를 이동할 때마다 클라이언트에서 전체 페이지가 다시 렌더링 되어야 함..

### 5. Soft Navigation
- Hard Navigation : 브라우저는 일반적으로 hard navigation을 수행. 
  - 전체 페이지를 새로 불러오고 렌더링.

#### 📌 Next.js의 App Router
 - Soft Navigation을 가능하게 함.
 - 바뀐 라우트 세그먼트만 다시 렌더링하는 부분 렌더링(partial rendering)을 지원. 

 - 페이지 간 이동을 하더라도 클라이언트 측의 React 상태가 유지될 수 있음. (ex. 입력한 폼 내용, 탭 선택 상태 등)


### 6. Back and Forward Navigation
Next.js에서 backwards and forwards navigation 할 때 
 -  스크롤 위치를 그대로 유지
 - 라우터 캐시에 저장된 라우트 세그먼트도 재사용

### 7. Routing between ```pages/``` and ```app/```
- ```pages/```에서 ```app/```으로 점진적으로 마이그레이션할 때, 라우터는 두 디렉토리 간의 hard navigation을 자동으로 처리해줌. 

- Next.js : ```pages/``` → ```app/``` 으로 전환되는 시점을 감지하기 위해 클라이언트 라우터 필터를 사용함. 이는 확률적(probabilistic) 방식으로 ```app/``` 라우트를 체크함.
  - ( Next.js가 ```pages/``` → ```app/``` 으로 이동하는 라우팅 상황에서 "이 경로가 app/ 라우트인지 아닌지" 이걸 매번 100% 정확히 서버에 요청하거나, 전체 라우트 정보를 다 들고 있지 않고도 거의 정확하게 예측할 수 있는 알고리즘을 사용한다고 합니다 )
  - 가끔 잘못 감지할 수 있는데 그 확률은 매우 희박 

- 확률은 ```next.config.js``` 의 ```experimental.clientRouterFilterAllowedRate``` 옵션을 통해 조절할 수 있는데, false positive 확률을 낮추면 필터 자체가 커져서 클라이언트 번들의 크기가 증가하게 된다는 점도 고려해야 함. 

- 자동 처리를 완전히 비활성화하고, ```pages/``` ↔ ```app/``` 사이의 라우팅을 직접 수동으로 관리하고 싶다면, ```next.config.js```에서 ```experimental.clientRouterFilter```를 ```false```로 설정하면 된다. 하지만, 이 기능을 끄면 ```pages/```에서 정의된 동적 라우트가 ```app/```의 라우트와 겹친다면 기본적으로는 그 경로로 제대로 이동되지 않을 수 있으니 주의해야 함. 







